/*
ArchiveBox API

 <h3>Welcome to your ArchiveBox server's REST API <code>[v1 ALPHA]</code> homepage!</h3> <br/> <i><b>WARNING: This API is still in an early development stage and may change!</b></i> <br/> <ul> <li>‚¨ÖÔ∏è Manage your server: <a href=\"/admin/api/\"><b>Setup API Keys</b></a>, <a href=\"/admin/\">Go to your Server Admin UI</a>, <a href=\"/\">Go to your Snapshots list</a>  <li>üí¨ Ask questions and get help here: <a href=\"https://zulip.archivebox.io\">ArchiveBox Chat Forum</a></li> <li>üêû Report API bugs here: <a href=\"https://github.com/ArchiveBox/ArchiveBox/issues\">Github Issues</a></li> <li>üìö ArchiveBox Documentation: <a href=\"https://github.com/ArchiveBox/ArchiveBox/wiki\">Github Wiki</a></li> <li>üìú See the API source code: <a href=\"https://github.com/ArchiveBox/ArchiveBox/blob/dev/archivebox/api\"><code>archivebox/api/</code></a></li> </ul> <small>Served by ArchiveBox v0.8.5rc50 (<a href=\"https://github.com/ArchiveBox/ArchiveBox/commit/1dff8bae4043efb678c1a6fb517dfa7e7a211150\"><code>1dff8bae</code></a>), API powered by <a href=\"https://django-ninja.dev/\"><code>django-ninja</code></a>.</small> 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// CoreModelsAPIService CoreModelsAPI service
type CoreModelsAPIService service

type ApiApiV1CoreGetAnyRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	abid string
}

func (r ApiApiV1CoreGetAnyRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetAnyExecute(r)
}

/*
ApiV1CoreGetAny Get Any

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param abid
 @return ApiApiV1CoreGetAnyRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetAny(ctx context.Context, abid string) ApiApiV1CoreGetAnyRequest {
	return ApiApiV1CoreGetAnyRequest{
		ApiService: a,
		ctx: ctx,
		abid: abid,
	}
}

// Execute executes the request
//  @return Response
func (a *CoreModelsAPIService) ApiV1CoreGetAnyExecute(r ApiApiV1CoreGetAnyRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetAny")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/any/{abid}"
	localVarPath = strings.Replace(localVarPath, "{"+"abid"+"}", url.PathEscape(parameterValueToString(r.abid, "abid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetArchiveresultRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	archiveresultId string
}

func (r ApiApiV1CoreGetArchiveresultRequest) Execute() (*ArchiveResultSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetArchiveresultExecute(r)
}

/*
ApiV1CoreGetArchiveresult Get Archiveresult

Get a specific ArchiveResult by id or abid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param archiveresultId
 @return ApiApiV1CoreGetArchiveresultRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetArchiveresult(ctx context.Context, archiveresultId string) ApiApiV1CoreGetArchiveresultRequest {
	return ApiApiV1CoreGetArchiveresultRequest{
		ApiService: a,
		ctx: ctx,
		archiveresultId: archiveresultId,
	}
}

// Execute executes the request
//  @return ArchiveResultSchema
func (a *CoreModelsAPIService) ApiV1CoreGetArchiveresultExecute(r ApiApiV1CoreGetArchiveresultRequest) (*ArchiveResultSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArchiveResultSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetArchiveresult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/archiveresult/{archiveresult_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"archiveresult_id"+"}", url.PathEscape(parameterValueToString(r.archiveresultId, "archiveresultId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetArchiveresultsRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	id *string
	search *string
	snapshotId *string
	snapshotUrl *string
	snapshotTag *string
	status *string
	output *string
	extractor *string
	cmd *string
	pwd *string
	cmdVersion *string
	createdAt *time.Time
	createdAtGte *time.Time
	createdAtLt *time.Time
	limit *int32
	offset *int32
	page *int32
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Id(id string) ApiApiV1CoreGetArchiveresultsRequest {
	r.id = &id
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Search(search string) ApiApiV1CoreGetArchiveresultsRequest {
	r.search = &search
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) SnapshotId(snapshotId string) ApiApiV1CoreGetArchiveresultsRequest {
	r.snapshotId = &snapshotId
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) SnapshotUrl(snapshotUrl string) ApiApiV1CoreGetArchiveresultsRequest {
	r.snapshotUrl = &snapshotUrl
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) SnapshotTag(snapshotTag string) ApiApiV1CoreGetArchiveresultsRequest {
	r.snapshotTag = &snapshotTag
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Status(status string) ApiApiV1CoreGetArchiveresultsRequest {
	r.status = &status
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Output(output string) ApiApiV1CoreGetArchiveresultsRequest {
	r.output = &output
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Extractor(extractor string) ApiApiV1CoreGetArchiveresultsRequest {
	r.extractor = &extractor
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Cmd(cmd string) ApiApiV1CoreGetArchiveresultsRequest {
	r.cmd = &cmd
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Pwd(pwd string) ApiApiV1CoreGetArchiveresultsRequest {
	r.pwd = &pwd
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) CmdVersion(cmdVersion string) ApiApiV1CoreGetArchiveresultsRequest {
	r.cmdVersion = &cmdVersion
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) CreatedAt(createdAt time.Time) ApiApiV1CoreGetArchiveresultsRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) CreatedAtGte(createdAtGte time.Time) ApiApiV1CoreGetArchiveresultsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) CreatedAtLt(createdAtLt time.Time) ApiApiV1CoreGetArchiveresultsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Limit(limit int32) ApiApiV1CoreGetArchiveresultsRequest {
	r.limit = &limit
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Offset(offset int32) ApiApiV1CoreGetArchiveresultsRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Page(page int32) ApiApiV1CoreGetArchiveresultsRequest {
	r.page = &page
	return r
}

func (r ApiApiV1CoreGetArchiveresultsRequest) Execute() (*PagedArchiveResultSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetArchiveresultsExecute(r)
}

/*
ApiV1CoreGetArchiveresults Get Archiveresults

List all ArchiveResult entries matching these filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1CoreGetArchiveresultsRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetArchiveresults(ctx context.Context) ApiApiV1CoreGetArchiveresultsRequest {
	return ApiApiV1CoreGetArchiveresultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagedArchiveResultSchema
func (a *CoreModelsAPIService) ApiV1CoreGetArchiveresultsExecute(r ApiApiV1CoreGetArchiveresultsRequest) (*PagedArchiveResultSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagedArchiveResultSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetArchiveresults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/archiveresults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.snapshotId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshot_id", r.snapshotId, "form", "")
	}
	if r.snapshotUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshot_url", r.snapshotUrl, "form", "")
	}
	if r.snapshotTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshot_tag", r.snapshotTag, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.output != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output", r.output, "form", "")
	}
	if r.extractor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extractor", r.extractor, "form", "")
	}
	if r.cmd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cmd", r.cmd, "form", "")
	}
	if r.pwd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pwd", r.pwd, "form", "")
	}
	if r.cmdVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cmd_version", r.cmdVersion, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__gte", r.createdAtGte, "form", "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__lt", r.createdAtLt, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 200
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetSnapshotRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	snapshotId string
	withArchiveresults *bool
}

func (r ApiApiV1CoreGetSnapshotRequest) WithArchiveresults(withArchiveresults bool) ApiApiV1CoreGetSnapshotRequest {
	r.withArchiveresults = &withArchiveresults
	return r
}

func (r ApiApiV1CoreGetSnapshotRequest) Execute() (*SnapshotSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetSnapshotExecute(r)
}

/*
ApiV1CoreGetSnapshot Get Snapshot

Get a specific Snapshot by abid or id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId
 @return ApiApiV1CoreGetSnapshotRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetSnapshot(ctx context.Context, snapshotId string) ApiApiV1CoreGetSnapshotRequest {
	return ApiApiV1CoreGetSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return SnapshotSchema
func (a *CoreModelsAPIService) ApiV1CoreGetSnapshotExecute(r ApiApiV1CoreGetSnapshotRequest) (*SnapshotSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SnapshotSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/snapshot/{snapshot_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshot_id"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withArchiveresults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_archiveresults", r.withArchiveresults, "form", "")
	} else {
		var defaultValue bool = true
		r.withArchiveresults = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetSnapshotsRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	id *string
	abid *string
	createdById *string
	createdByUsername *string
	createdAtGte *time.Time
	createdAtLt *time.Time
	createdAt *time.Time
	modifiedAt *time.Time
	modifiedAtGte *time.Time
	modifiedAtLt *time.Time
	search *string
	url *string
	tag *string
	title *string
	timestamp *string
	bookmarkedAtGte *time.Time
	bookmarkedAtLt *time.Time
	withArchiveresults *bool
	limit *int32
	offset *int32
	page *int32
}

func (r ApiApiV1CoreGetSnapshotsRequest) Id(id string) ApiApiV1CoreGetSnapshotsRequest {
	r.id = &id
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Abid(abid string) ApiApiV1CoreGetSnapshotsRequest {
	r.abid = &abid
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) CreatedById(createdById string) ApiApiV1CoreGetSnapshotsRequest {
	r.createdById = &createdById
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) CreatedByUsername(createdByUsername string) ApiApiV1CoreGetSnapshotsRequest {
	r.createdByUsername = &createdByUsername
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) CreatedAtGte(createdAtGte time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) CreatedAtLt(createdAtLt time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) CreatedAt(createdAt time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) ModifiedAt(modifiedAt time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.modifiedAt = &modifiedAt
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) ModifiedAtGte(modifiedAtGte time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.modifiedAtGte = &modifiedAtGte
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) ModifiedAtLt(modifiedAtLt time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.modifiedAtLt = &modifiedAtLt
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Search(search string) ApiApiV1CoreGetSnapshotsRequest {
	r.search = &search
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Url(url string) ApiApiV1CoreGetSnapshotsRequest {
	r.url = &url
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Tag(tag string) ApiApiV1CoreGetSnapshotsRequest {
	r.tag = &tag
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Title(title string) ApiApiV1CoreGetSnapshotsRequest {
	r.title = &title
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Timestamp(timestamp string) ApiApiV1CoreGetSnapshotsRequest {
	r.timestamp = &timestamp
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) BookmarkedAtGte(bookmarkedAtGte time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.bookmarkedAtGte = &bookmarkedAtGte
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) BookmarkedAtLt(bookmarkedAtLt time.Time) ApiApiV1CoreGetSnapshotsRequest {
	r.bookmarkedAtLt = &bookmarkedAtLt
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) WithArchiveresults(withArchiveresults bool) ApiApiV1CoreGetSnapshotsRequest {
	r.withArchiveresults = &withArchiveresults
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Limit(limit int32) ApiApiV1CoreGetSnapshotsRequest {
	r.limit = &limit
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Offset(offset int32) ApiApiV1CoreGetSnapshotsRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Page(page int32) ApiApiV1CoreGetSnapshotsRequest {
	r.page = &page
	return r
}

func (r ApiApiV1CoreGetSnapshotsRequest) Execute() (*PagedSnapshotSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetSnapshotsExecute(r)
}

/*
ApiV1CoreGetSnapshots Get Snapshots

List all Snapshot entries matching these filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1CoreGetSnapshotsRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetSnapshots(ctx context.Context) ApiApiV1CoreGetSnapshotsRequest {
	return ApiApiV1CoreGetSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagedSnapshotSchema
func (a *CoreModelsAPIService) ApiV1CoreGetSnapshotsExecute(r ApiApiV1CoreGetSnapshotsRequest) (*PagedSnapshotSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagedSnapshotSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.abid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "abid", r.abid, "form", "")
	}
	if r.createdById != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_id", r.createdById, "form", "")
	}
	if r.createdByUsername != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by_username", r.createdByUsername, "form", "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__gte", r.createdAtGte, "form", "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at__lt", r.createdAtLt, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.modifiedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_at", r.modifiedAt, "form", "")
	}
	if r.modifiedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_at__gte", r.modifiedAtGte, "form", "")
	}
	if r.modifiedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_at__lt", r.modifiedAtLt, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "form", "")
	}
	if r.bookmarkedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmarked_at__gte", r.bookmarkedAtGte, "form", "")
	}
	if r.bookmarkedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmarked_at__lt", r.bookmarkedAtLt, "form", "")
	}
	if r.withArchiveresults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_archiveresults", r.withArchiveresults, "form", "")
	} else {
		var defaultValue bool = false
		r.withArchiveresults = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 200
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetTagRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	tagId string
	withSnapshots *bool
}

func (r ApiApiV1CoreGetTagRequest) WithSnapshots(withSnapshots bool) ApiApiV1CoreGetTagRequest {
	r.withSnapshots = &withSnapshots
	return r
}

func (r ApiApiV1CoreGetTagRequest) Execute() (*TagSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetTagExecute(r)
}

/*
ApiV1CoreGetTag Get Tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagId
 @return ApiApiV1CoreGetTagRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetTag(ctx context.Context, tagId string) ApiApiV1CoreGetTagRequest {
	return ApiApiV1CoreGetTagRequest{
		ApiService: a,
		ctx: ctx,
		tagId: tagId,
	}
}

// Execute executes the request
//  @return TagSchema
func (a *CoreModelsAPIService) ApiV1CoreGetTagExecute(r ApiApiV1CoreGetTagRequest) (*TagSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/tag/{tag_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tag_id"+"}", url.PathEscape(parameterValueToString(r.tagId, "tagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_snapshots", r.withSnapshots, "form", "")
	} else {
		var defaultValue bool = true
		r.withSnapshots = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1CoreGetTagsRequest struct {
	ctx context.Context
	ApiService *CoreModelsAPIService
	limit *int32
	offset *int32
	page *int32
}

func (r ApiApiV1CoreGetTagsRequest) Limit(limit int32) ApiApiV1CoreGetTagsRequest {
	r.limit = &limit
	return r
}

func (r ApiApiV1CoreGetTagsRequest) Offset(offset int32) ApiApiV1CoreGetTagsRequest {
	r.offset = &offset
	return r
}

func (r ApiApiV1CoreGetTagsRequest) Page(page int32) ApiApiV1CoreGetTagsRequest {
	r.page = &page
	return r
}

func (r ApiApiV1CoreGetTagsRequest) Execute() (*PagedTagSchema, *http.Response, error) {
	return r.ApiService.ApiV1CoreGetTagsExecute(r)
}

/*
ApiV1CoreGetTags Get Tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1CoreGetTagsRequest
*/
func (a *CoreModelsAPIService) ApiV1CoreGetTags(ctx context.Context) ApiApiV1CoreGetTagsRequest {
	return ApiApiV1CoreGetTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagedTagSchema
func (a *CoreModelsAPIService) ApiV1CoreGetTagsExecute(r ApiApiV1CoreGetTagsRequest) (*PagedTagSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagedTagSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CoreModelsAPIService.ApiV1CoreGetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/core/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 200
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["HeaderTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-ArchiveBox-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["QueryParamTokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
